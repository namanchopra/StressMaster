import {
  BaseAIProvider,
  CompletionRequest,
  CompletionResponse,
  AIProviderConfig,
} from "../ai-provider";

/**
 * Google Gemini Provider - Supports Gemini Pro and other Google AI models
 * Requires API key from https://makersuite.google.com/app/apikey
 */
export class GeminiProvider extends BaseAIProvider {
  private static readonly DEFAULT_ENDPOINT =
    "https://generativelanguage.googleapis.com/v1beta";
  private static readonly DEFAULT_MODEL = "gemini-pro";

  constructor(config: AIProviderConfig) {
    super({
      endpoint: GeminiProvider.DEFAULT_ENDPOINT,
      ...config,
      model: config.model || GeminiProvider.DEFAULT_MODEL,
    });
  }

  async initialize(): Promise<void> {
    if (!this.config.apiKey) {
      throw new Error(
        "Google AI API key is required. Set AI_API_KEY environment variable."
      );
    }

    try {
      await this.healthCheck();
      this.isInitialized = true;
      console.log(
        `Gemini Provider initialized with model: ${this.config.model}`
      );
    } catch (error) {
      throw new Error(`Failed to initialize Gemini provider: ${error}`);
    }
  }

  async generateCompletion(
    request: CompletionRequest
  ): Promise<CompletionResponse> {
    const startTime = Date.now();

    return this.retryOperation(async () => {
      const model = request.model || this.config.model;
      const url = `${this.config.endpoint}/models/${model}:generateContent?key=${this.config.apiKey}`;

      const systemInstruction =
        "You are a helpful assistant that converts natural language into structured load test specifications. Always respond with valid JSON when requested.";
      const fullPrompt = `${systemInstruction}\n\nUser request: ${request.prompt}`;

      const response = await fetch(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          contents: [
            {
              parts: [
                {
                  text: fullPrompt,
                },
              ],
            },
          ],
          generationConfig: {
            temperature: request.temperature || 0.1,
            maxOutputTokens: request.maxTokens || 2000,
            topP: 0.8,
            topK: 10,
          },
          safetySettings: [
            {
              category: "HARM_CATEGORY_HARASSMENT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE",
            },
            {
              category: "HARM_CATEGORY_HATE_SPEECH",
              threshold: "BLOCK_MEDIUM_AND_ABOVE",
            },
            {
              category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE",
            },
            {
              category: "HARM_CATEGORY_DANGEROUS_CONTENT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE",
            },
          ],
        }),
      });

      if (!response.ok) {
        const errorData = (await response.json().catch(() => ({}))) as any;
        throw new Error(
          `Gemini API error: ${response.status} - ${
            errorData.error?.message || response.statusText
          }`
        );
      }

      const data = (await response.json()) as any;
      const duration = Date.now() - startTime;

      if (!data.candidates || data.candidates.length === 0) {
        throw new Error("No response generated by Gemini");
      }

      const candidate = data.candidates[0];
      if (candidate.finishReason === "SAFETY") {
        throw new Error("Response blocked by Gemini safety filters");
      }

      return {
        response: candidate.content.parts[0].text,
        model: model,
        usage: {
          promptTokens: data.usageMetadata?.promptTokenCount,
          completionTokens: data.usageMetadata?.candidatesTokenCount,
          totalTokens: data.usageMetadata?.totalTokenCount,
        },
        metadata: {
          provider: "gemini",
          duration,
        },
      };
    });
  }

  async healthCheck(): Promise<boolean> {
    try {
      const model = this.config.model;
      const url = `${this.config.endpoint}/models/${model}?key=${this.config.apiKey}`;

      const response = await fetch(url);
      return response.ok;
    } catch (error) {
      return false;
    }
  }

  getProviderName(): string {
    return "Google Gemini";
  }
}
